<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>{{title}}</title>
  <script src="https://unpkg.com/force-graph"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      /* prevent scrollbars */
    }
    #controls {
      width: 300px;
      max-height: 100px;
      position: fixed;
      top: 10px;
      right: 16px;
      border: 1px dashed gray;
      background: rgba(255, 255, 255, 0.5);
      padding: 6px;
    }
    #controls input {
      width: 100%;
    }
    .control__label {
      font-size: 10px;
    }
  </style>
</head>

<body>
  <div id="container"></div>
  <div id="controls">
    <div class="control__setting">
      <span class="control__label">Node threshold</span>
      <input type="range" min="1" max="1000" value="10" class="slider" id="node-threshold-slider">
    </div>
    <div class="control__setting">
      <span class="control__label">Link threshold</span>
      <input type="range" min="1" max="100" value="10" class="slider" id="link-threshold-slider">
    </div>
  </div>

  <script>
    const nodes = [
      {% for name, info in user_info_map.items() -%}
          { id: "{{name}}", color: "{{info.color}}", count: {{info.count}} },
      {% endfor %}
    ];

    const links = [
      {% for link in review_links -%}
          { source: "{{link.reviewer}}", target: "{{link.reviewee}}", count: {{link.count}} },
      {% endfor %}
    ];
  </script>

  <script>
    const container = document.getElementById("container");
    const myGraph = ForceGraph();
    myGraph(container)
      .nodeVal((node) => {
        return node.size;
      })
      .linkWidth((link) => {
        return Math.min(10, Math.max(0.5, Math.log(link.count, 2) - 2));
      })
      .linkDirectionalArrowLength((link) => {
        return Math.min(10, Math.max(0.5, Math.log(link.count, 2) - 2));
      })
      .linkDirectionalArrowRelPos(0.7)
      .nodeCanvasObject((node, ctx, globalScale) => {
        const label = node.id;
        const fontSizeExtra = Math.log(node.count, 2);
        const fontSize = (10 + fontSizeExtra) / globalScale;
        ctx.font = `${fontSize}px Sans-Serif`;
        const textWidth = ctx.measureText(label).width;
        const bckgDimensions = [textWidth, fontSize].map(n => n + fontSize * 0.2); // some padding

        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.fillRect(node.x - bckgDimensions[0] / 2, node.y - bckgDimensions[1] / 2, ...bckgDimensions);

        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = node.color;
        ctx.fillText(label, node.x, node.y);

        node.__bckgDimensions = bckgDimensions; // to re-use in nodePointerAreaPaint
      })
      .nodePointerAreaPaint((node, color, ctx) => {
        ctx.fillStyle = color;
        const bckgDimensions = node.__bckgDimensions;
        bckgDimensions && ctx.fillRect(node.x - bckgDimensions[0] / 2, node.y - bckgDimensions[1] / 2, ...bckgDimensions);
      })
      .graphData({
        "nodes": nodes,
        "links": links,
      });
  </script>

  <script>
    function getFilteredGraphData(nodeCountThreshold, linkCountThreshold) {
      console.log(`node threshold ${nodeCountThreshold} link threshold ${linkCountThreshold}`);

      const filteredNodes = nodes.filter(node => {
        return node.count >= nodeCountThreshold;
      });

      const filteredNodeIds = new Set(filteredNodes.map(node => node.id));

      const filteredLinks = links.filter(link => {
        return (
          link.count >= linkCountThreshold &&
          filteredNodeIds.has(link.source.id) &&
          filteredNodeIds.has(link.target.id)
        );
      });

      console.log(`nodes left: ${filteredNodes.length}, links ${filteredLinks.length}`);

      return {
        "nodes": filteredNodes,
        "links": filteredLinks,
      }
    }

    const nodeSliderElement = document.getElementById("node-threshold-slider");
    const linkSliderElement = document.getElementById("link-threshold-slider");

    function handleThresholdsChange() {
      const nodeThresholdValue = parseFloat(nodeSliderElement.value);
      const linkThresholdValue = parseFloat(linkSliderElement.value);
      const graphData = getFilteredGraphData(nodeThresholdValue, linkThresholdValue);
      myGraph.graphData(graphData);
    }

    nodeSliderElement.oninput = function (event) {
      handleThresholdsChange();
    }

    linkSliderElement.oninput = function (event) {
      handleThresholdsChange();
    }

    // handle initial state
    document.onload += handleThresholdsChange;
  </script>
</body>
</html>
