<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>{{title}}</title>
  <script src="https://unpkg.com/force-graph"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap"
    rel="stylesheet">
  <link
    href="https://fonts.googleapis.com/css2?family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap"
    rel="stylesheet">
  <style>
    html, body, #container, #graph-container {
      height: 100%;
      width: 100%;
    }
    body {
      margin: 0;
      /* prevent scrollbars */
      overflow: hidden;
      font-family: "Ubuntu";
    }
    #container {
      position: relative;
    }
    #controls {
      width: 300px;
      position: absolute;
      top: 10px;
      right: 16px;
      border: 1px dashed gray;
      background: rgba(255, 255, 255, 0.5);
      padding: 6px;
    }
    .control__setting {
      display: flex;
      align-items: center;
      margin-bottom: 4px;
    }
    #controls input[type="range"] {
      width: 100%;
    }
    #controls input[type="text"] {
      width: 100%;
      font-family: "Ubuntu";
    }
    .control__label {
      font-size: 10px;
      min-width: 100px;
    }
  </style>
</head>

<body>
  <div id="container">
    <div id="graph-container"></div>
    <div id="controls">
      <div class="control__setting">
        <span class="control__label">Node threshold</span>
        <input type="range" min="1" max="1000" value="10" class="slider" id="node-threshold-slider">
      </div>
      <div class="control__setting">
        <span class="control__label">Link threshold</span>
        <input type="range" min="1" max="100" value="10" class="slider" id="link-threshold-slider">
      </div>
      <div class="control__setting">
        <span class="control__label">Start date</span>
        <input type="range" min="0" max="100" value="0" class="slider" id="start-date-slider">
      </div>
      <div class="control__setting">
        <span class="control__label">End date</span>
        <input type="range" min="0" max="100" value="100" class="slider" id="end-date-slider">
      </div>
      <div class="control__setting">
        <input type="checkbox" checked id="approvedOnlyCheckbox">
        <span class="control__label">Approvals only</span>
      </div>
      <div class="control__setting">
        <input type="text" placeholder="find" id="findTextbox">
      </div>
    </div>
  </div>

  <script>
    // TODO: use map based encoding to save space
    const data_raw = [
      {% for item in data_model -%}
          ["{{item.reviewer}}", "{{item.reviewee}}", "{{item.timestamp}}", {{ 'true' if item.has_approved else 'false' }}],
      {% endfor %}
    ];

    // post-load processing
    const data = [];
    data_raw.forEach(([reviewer, reviewee, timestamp_str, has_approved]) => {
      const timestamp = new Date(timestamp_str);
      data.push({ reviewer, reviewee, timestamp, has_approved });
    });
  </script>

  <script>
    const defaultColor = "#3777de";
    const highlightColor = "#e25548";
    const accentColor = "#7a18d6";

    const graphContainer = document.getElementById("graph-container");
    const myGraph = ForceGraph();
    myGraph(graphContainer)
      .linkWidth((link) => {
        return Math.min(10, Math.max(0.5, Math.log(link.count, 2) - 2));
      })
      .linkColor((link) => {
        if (link.isAccented) {
          return accentColor;
        } else {
          return link.color;
        }
      })
      .linkDirectionalArrowLength((link) => {
        return Math.min(10, Math.max(0.5, Math.log(link.count, 2) - 2));
      })
      .linkDirectionalArrowRelPos(0.7)
      .nodeCanvasObject((node, ctx, globalScale) => {
        const label = node.id;
        const totalCount = node.review_given + node.review_received;
        const fontSizeExtra = Math.log(totalCount, 2);
        const fontSize = (10 + fontSizeExtra) / globalScale;

        if (node.isHighlighted) {
          ctx.font = `bold ${fontSize}px Ubuntu`;
        } else if (node.isAccented) {
          ctx.font = `bold ${fontSize}px Ubuntu`;
        } else {
          ctx.font = `${fontSize}px Ubuntu`;
        }

        const textWidth = ctx.measureText(label).width;
        const bckgDimensions = [textWidth, fontSize].map(n => n + fontSize * 0.2); // some padding

        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.fillRect(node.x - bckgDimensions[0] / 2, node.y - bckgDimensions[1] / 2, ...bckgDimensions);

        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        if (node.isHighlighted) {
          ctx.fillStyle = highlightColor;
        } else if (node.isAccented) {
          ctx.fillStyle = accentColor;
        } else {
          ctx.fillStyle = node.color;
        }

        ctx.fillText(label, node.x, node.y);

        node.__bckgDimensions = bckgDimensions; // to re-use in nodePointerAreaPaint
      })
      .nodePointerAreaPaint((node, color, ctx) => {
        ctx.fillStyle = color;
        const bckgDimensions = node.__bckgDimensions;
        bckgDimensions && ctx.fillRect(node.x - bckgDimensions[0] / 2, node.y - bckgDimensions[1] / 2, ...bckgDimensions);
      });

    function handleResize() {
      const clientWidth = graphContainer.clientWidth;
      const clientHeight = graphContainer.clientHeight;

      myGraph.width(clientWidth);
      myGraph.height(clientHeight);
    }

    // handle resize
    window.addEventListener('resize', handleResize);
  </script>

  <script>
    const nodeSliderElement = document.getElementById("node-threshold-slider");
    const linkSliderElement = document.getElementById("link-threshold-slider");
    const startDateSliderElement = document.getElementById("start-date-slider");
    const endDateSliderElement = document.getElementById("end-date-slider");
    const approvedOnlyCheckboxElement = document.getElementById("approvedOnlyCheckbox");
    const findTextboxElement = document.getElementById("findTextbox");

    function interpolateDate(date1, date2, factor) {
      const time1 = date1.getTime();
      const time2 = date2.getTime();
      const interpolatedTime = time1 + (time2 - time1) * factor;
      return new Date(interpolatedTime);
    }

    function findMinMaxDates(data) {
        if (!data || data.length === 0) {
          return { min: null, max: null };
        }

        let minDate = new Date(data[0].timestamp);
        let maxDate = new Date(data[0].timestamp);

        for (let i = 1; i < data.length; i++) {
          const currentDate = new Date(data[i].timestamp);
          if (currentDate < minDate) {
            minDate = currentDate;
          }
          if (currentDate > maxDate) {
            maxDate = currentDate;
          }
        }

        return { min: minDate, max: maxDate };
      }

    function aggregateReviews() {
      const linkMap = new Map();
      const nodesMap = new Map();

      const dateRange = findMinMaxDates(data);
      const startThresholdFactor = parseFloat(startDateSliderElement.value) / parseFloat(startDateSliderElement.max);
      const startThreshold = interpolateDate(dateRange.min, dateRange.max, startThresholdFactor);
      const endThresholdFactor = parseFloat(endDateSliderElement.value) / parseFloat(endDateSliderElement.max);
      const endThreshold = interpolateDate(dateRange.min, dateRange.max, endThresholdFactor);
      const approvedOnly = approvedOnlyCheckboxElement.checked;

      console.log(`date range: [${startThreshold}, ${endThreshold}]`);

      data.forEach(({ reviewer, reviewee, timestamp, has_approved }) => {
        const key = `${reviewer} :: ${reviewee}`;

        if (timestamp < startThreshold || timestamp > endThreshold) {
          return;
        }

        if (approvedOnly && !has_approved) {
          return;
        }

        if (!linkMap.has(key)) {
          linkMap.set(key, { id: key, source: reviewer, target: reviewee, count: 0 });
        }

        linkMap.get(key).count += 1;

        if (!nodesMap.has(reviewer)) {
          nodesMap.set(reviewer, { id: reviewer, review_given: 0, review_received: 0, color: defaultColor });
        }
        if (!nodesMap.has(reviewee)) {
          nodesMap.set(reviewee, { id: reviewee, review_given: 0, review_received: 0, color: defaultColor });
        }

        nodesMap.get(reviewer).review_given += 1;
        nodesMap.get(reviewee).review_received += 1;
      });

      return {
        "links": Array.from(linkMap.values()),
        "nodes": Array.from(nodesMap.values()),
      }
    }

    function getFilteredGraphData(nodeCountThreshold, linkCountThreshold) {
      console.log(`node threshold ${nodeCountThreshold} link threshold ${linkCountThreshold}`);

      // compose nodes and edges lists
      const aggregated = aggregateReviews();

      const filteredNodes = aggregated["nodes"].filter(node => {
        return (node.review_given + node.review_received) >= nodeCountThreshold;
      });

      const filteredNodeIds = new Set(filteredNodes.map(node => node.id));

      const filteredLinks = aggregated["links"].filter(link => {
        return (
          link.count >= linkCountThreshold &&
          filteredNodeIds.has(link.source) &&
          filteredNodeIds.has(link.target)
        );
      });

      console.log(`nodes left: ${filteredNodes.length}, links ${filteredLinks.length}`);

      return {
        "nodes": filteredNodes,
        "links": filteredLinks,
      }
    }

    function smartUpdate(sourceArray, targetArray, identityFunc) {
      const sourceMap = new Map();
      const targetMap = new Map();

      sourceArray.forEach(item => sourceMap.set(identityFunc(item), item));
      targetArray.forEach(item => targetMap.set(identityFunc(item), item));

      // drop ones which no longer present
      for (let i = targetArray.length - 1; i >= 0; i--) {
        const identity = identityFunc(targetArray[i]);
        if (!sourceMap.has(identity)) {
          targetArray.splice(i, 1);
        }
      }

      // now iterate the source and either update the existing matching ones or create new
      sourceArray.forEach((item) => {
        const identity = identityFunc(item);
        if (targetMap.has(identity)) {
          Object.assign(targetMap.get(identity), sourceMap.get(identity));
        } else {
          targetArray.push(item);
        }
      })
    }

    const graphData = {
      "nodes": [],
      "links": [],
    }

    // tries to preserve the objects in the target array if matching found
    // by the indentity function
    const nodesPoolMap = new Map();
    const linksPoolMap = new Map();

    // never delets object from pool allowing force graph to maintain the state
    function poolObjects(array, poolMap, identityFunc) {
      let result = [];
      array.forEach((item) => {
        const identity = identityFunc(item);
        if (poolMap.has(identity)) {
          Object.assign(poolMap.get(identity), item);
        } else {
          poolMap.set(identity, item);
        }
        result.push(poolMap.get(identity));
      });
      return result;
    }

    // maintains objects identity in the graph data, so that graph can change
    // w/o full redraw
    function updateGraphData(newGraphData) {
      graphData["nodes"] = poolObjects(newGraphData["nodes"], nodesPoolMap, x => x.id);
      graphData["links"] = poolObjects(newGraphData["links"], linksPoolMap, x => x.id);
      myGraph.graphData(graphData);
    }

    function handleSearch(graphData) {
      const searchText = findTextboxElement.value.toLowerCase();
      graphData["nodes"].forEach((node) => {
        if (searchText && node.id.toLowerCase().includes(searchText)) {
          node.isHighlighted = true;
        } else {
          node.isHighlighted = false;
        }
      });
    }

    function recompute() {
      console.log('recomputing...');
      const nodeThresholdValue = parseFloat(nodeSliderElement.value);
      const linkThresholdValue = parseFloat(linkSliderElement.value);
      const filtered = getFilteredGraphData(nodeThresholdValue, linkThresholdValue);
      handleSearch(filtered);
      updateGraphData(filtered);
    }

    nodeSliderElement.onchange = (event) => recompute();
    linkSliderElement.onchange = (event) => recompute();
    startDateSliderElement.onchange = (event) => recompute();
    endDateSliderElement.onchange = (event) => recompute();
    approvedOnlyCheckboxElement.onchange = (event) => recompute();
    findTextboxElement.oninput = (event) => recompute();

    // handle initial state
    document.addEventListener('DOMContentLoaded', function () {
      recompute()
    });
  </script>
  <script>
    let isDragStartHandled = false;

    function getNeighbors(nodeId) {
      let neighborsIds = new Set();
      let linkIds = new Set();
      graphData.links.forEach((link) => {
        if (link.source.id == nodeId) {
          neighborsIds.add(link.target.id);
          linkIds.add(link.id);
        }
        if (link.target.id == nodeId) {
          neighborsIds.add(link.source.id);
          linkIds.add(link.id);
        }
      });
      return {
        nodes: neighborsIds,
        links: linkIds,
      }
    }

    myGraph.onNodeDrag((node, event) => {
      if (isDragStartHandled) {
        return;
      }
      isDragStartHandled = true;

      node.isAccented = true;

      const neighbors = getNeighbors(node.id);

      graphData.nodes.forEach((node) => {
        if (neighbors.nodes.has(node.id)) {
          node.isAccented = true;
        }
      });

      graphData.links.forEach((link) => {
        if (neighbors.links.has(link.id)) {
          link.isAccented = true;
          myGraph.emitParticle(link);
        }
      });
    });

    myGraph.onNodeDragEnd((node, event) => {
      isDragStartHandled = false;
      graphData.nodes.forEach((node) => {
        node.isAccented = false;
      });
      graphData.links.forEach((link) => {
        link.isAccented = false;
      });
    });
  </script>
</body>
</html>
